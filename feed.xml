<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://minngki.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://minngki.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-16T23:42:28+09:00</updated><id>https://minngki.github.io/feed.xml</id><title type="html">Minji Kim</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">MongoDB Aggregation Pipeline 내부 동작 원리와 최적화</title><link href="https://minngki.github.io/blog/2025/mongodb-aggregation/" rel="alternate" type="text/html" title="MongoDB Aggregation Pipeline 내부 동작 원리와 최적화"/><published>2025-01-14T22:20:00+09:00</published><updated>2025-01-14T22:20:00+09:00</updated><id>https://minngki.github.io/blog/2025/mongodb-aggregation</id><content type="html" xml:base="https://minngki.github.io/blog/2025/mongodb-aggregation/"><![CDATA[<p><a href="https://minngki.github.io/blog/2025/mongodb-pipeline/">MongoDB에서 ‘pipeline’이라는 표현을 사용하는 이유</a>가 궁금해 포스팅을 한 적이 있다. 그 과정에서 pipeline의 동작원리에 대해 더 깊은 궁금증이 생겨, 이번에는 MongoDB의 동작 원리를 파헤치고 정리한 글이다.</p> <h2 id="aggregation-pipeline의-내부-동작-개요">Aggregation Pipeline의 내부 동작 개요</h2> <p>이전에 작성한 글에서 MongoDB는 Aggregation Pipeline 실행 시 각 단계(<code class="language-plaintext highlighter-rouge">$match</code>, <code class="language-plaintext highlighter-rouge">$group</code>, <code class="language-plaintext highlighter-rouge">$sort</code>, <code class="language-plaintext highlighter-rouge">$lookup</code>)를 순차적으로 적용시킨다고 정리했었다. 여기서 더 세부적으로 정리하자면, Mongo 엔진은 다음과 같은 과정을 거친다.</p> <h4 id="1-parsing">1) Parsing</h4> <ul> <li>클라이언트가 전달한 pipeline array를 받아서, 각 단계에서 올바르고 유효한 문법인지 validate하는 과정이다.</li> <li>즉, 구문 분석과 타당성 검증을 담당한다.</li> </ul> <h4 id="2-planning">2) Planning</h4> <ul> <li>validation이 끝나면 실행 계획을 수립한다. 어떤 인덱스를 쓸지, 병렬 처리는 어떻게 할지, 단계의 순서는 어떻게 유지하거나 조정할지 등 실행 결로를 결정한다.</li> <li>실질적인 Optimization 작업이 이루어진다.</li> </ul> <h4 id="3-stage-execution">3) Stage Execution</h4> <ul> <li>실제 데이터(document)를 읽어서 각 단계의 <strong>연산(filtering, grouping, sorting)을 수행</strong>한다.</li> <li>각 단계는 독립적인 연산자처럼 동작하며, 앞 단계의 결과를 받아 연산 후 다음 단계로 넘어가는 방식이다.</li> </ul> <h4 id="4-returning">4) Returning</h4> <ul> <li>최종 단계까지 처리된 결과를 클라이언트에게 반환하거나, 특정 collection에 저장한다.</li> <li>해당 결과를 기존 collection에 덮어 쓸 수 있고, 새로운 collection 에 생성하거나 병합할 수 있다. <ul> <li>특정 collection에 기록하는 방법 <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">{</span>
      <span class="c1">// "aggregatedResults" collection이 없다면 새로 생성, or not 덮어쓰며 결과 저장.</span>
      <span class="dl">"</span><span class="s2">$out</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">aggregatedResults</span><span class="dl">"</span>
  <span class="p">}</span>
</code></pre></div> </div> </li> </ul> </li> </ul> <h2 id="optimization">Optimization</h2> <p>최적화 로직에 대해 조금만 자세히 살펴보자면,</p> <h4 id="1-인덱스-사용">1) 인덱스 사용</h4> <ul> <li><code class="language-plaintext highlighter-rouge">$sort</code> 앞 단계에서나 <code class="language-plaintext highlighter-rouge">$match</code>에 인덱스가 걸려 있으면, full collection 스캔을 최소화할 수 있게 index only scan을 진행하도록 실행 계획을 세운다. <ul> <li>Covered Query</li> </ul> </li> </ul> <h4 id="2-pipeline-stage-병합재배치">2) Pipeline stage 병합/재배치</h4> <ul> <li>내부적으로 <code class="language-plaintext highlighter-rouge">$match</code> 스테이지가 여러 번 등장하면, 가능한 한 앞단에서 합쳐서 수행하도록 최적화한다.</li> <li><code class="language-plaintext highlighter-rouge">$limit</code>,<code class="language-plaintext highlighter-rouge"> $skip</code> 등이 있다면, 이들을 앞단으로 당겨서 불필요한 연산을 줄일 수 있는지 검토한다.</li> <li><code class="language-plaintext highlighter-rouge">$sort</code>와 <code class="language-plaintext highlighter-rouge">$group</code>의 순서에 따라, 인덱스를 사용하는 방식이나 내부 동작이 달라지므로, 가끔 순서를 조정할 수도 있다.</li> </ul> <h2 id="mongo의-동작-원리-정리">mongo의 동작 원리 정리</h2> <h5 id="1-document-스캔-및-조회">1. Document 스캔 및 조회</h5> <ul> <li>파이프라인의 첫 단계에서 mongoDB는 collection에서 document를 읽기 시작한다.</li> <li><code class="language-plaintext highlighter-rouge">$match</code> 조건에 부합하는 문서만 통과시키기 때문에 앞 단에 <code class="language-plaintext highlighter-rouge">$match</code>로 filter를 걸어주는 게 효율적이다.</li> </ul> <h5 id="2-단계-별-연산-수행">2. 단계 별 연산 수행</h5> <h5 id="3-순차적으로-앞-단계의-결과를-다음-단계로-전달">3. 순차적으로 앞 단계의 결과를 다음 단계로 전달</h5> <h5 id="4-메모리디스크-사용">4. 메모리/디스크 사용</h5> <ul> <li><code class="language-plaintext highlighter-rouge">$sort</code>나 <code class="language-plaintext highlighter-rouge">$group</code>과 같은 많은 document를 한 번에 다루는 단계는 메모리에 중간 단계의 데이터를 보관한다.</li> <li>mongoDB는 기본 100MB까지 메모리를 사용하고, 이를 초과하면 <code class="language-plaintext highlighter-rouge">allowDiskUse</code> 옵션이 켜진 경우 디스크에 임시 공간을 활용한다고 한다. <ul> <li><em>회사에서 쌓인 log json은 크기가 커서 sort할 때, 과하게 오래 걸렸나 싶다..</em></li> </ul> </li> </ul> <h5 id="5-병렬-처리-sharded-cluster인-경우">5. 병렬 처리 (Sharded Cluster인 경우)</h5> <ul> <li>각 샤드에서 병렬로 부분 결과(ex.부분 집계)를 만들고, 해당 결과를 mongos(router) 혹은 최종 샤드에서 합치는 흐름을 거친다.</li> <li>수평 확장을 통해 대규모 데이터를 빠르게 처리할 때 사용한다.</li> <li><del>아직 사용해보지 않았지만 추후 다뤄보고 싶다..</del></li> </ul>]]></content><author><name></name></author><category term="study"/><category term="database"/><summary type="html"><![CDATA[MongoDB에서 ‘pipeline’이라는 표현을 사용하는 이유가 궁금해 포스팅을 한 적이 있다. 그 과정에서 pipeline의 동작원리에 대해 더 깊은 궁금증이 생겨, 이번에는 MongoDB의 동작 원리를 파헤치고 정리한 글이다.]]></summary></entry><entry><title type="html">MongoDB는 왜 ‘query’가 아니라 ‘pipeline’이라고 표현할까?</title><link href="https://minngki.github.io/blog/2025/mongodb-pipeline/" rel="alternate" type="text/html" title="MongoDB는 왜 ‘query’가 아니라 ‘pipeline’이라고 표현할까?"/><published>2025-01-13T04:20:00+09:00</published><updated>2025-01-13T04:20:00+09:00</updated><id>https://minngki.github.io/blog/2025/mongodb-pipeline</id><content type="html" xml:base="https://minngki.github.io/blog/2025/mongodb-pipeline/"><![CDATA[<p>jupyter에서 DB를 연결해서 데이터를 다룰 때, RDB는 당연하게도 query라는 변수를 사용하고, MongoDB는 pipeline이라는 변수를 사용하는 것을 발견했다. 문득 왜 pipeline이라는 표현을 하는지 궁금해져서 정리하는 글이다.</p> <h5 id="왜-mongo는-pipeline이라는-표현을-사용할까-">왜 Mongo는 pipeline이라는 표현을 사용할까 ?</h5> <p><code class="language-plaintext highlighter-rouge">Query</code>라는 표현 자체가 사용자가 원하는 특정 데이터가 무엇인지 명시(질의)하는 행위를 의미한다. 반면에, <code class="language-plaintext highlighter-rouge">Pipeline</code>은 데이터를 여러 단계에 거쳐 데이터를 처리하는 방식이다.</p> <p><code class="language-plaintext highlighter-rouge">Query</code>는 단순 질의를 강조하는 반면, <code class="language-plaintext highlighter-rouge">Pipeline</code>은 <strong>“처리 흐름”</strong>을 강조하는 용어로 보면 된다!</p> <p>겉으로는 당연한 것처럼 보일 수 있지만, 실제로 구조를 이해하면서 말로 풀어 보니 더 직관적으로 이해할 수 있었다.</p> <h2 id="파이프라인-개념">파이프라인 개념</h2> <p>파이프라인이란 데이터를 <strong>단계별로</strong> 처리하는 <strong>연속적인 작업</strong> 흐름을 말한다. Mongo의 aggregation pipeline 은 순차적으로 각 단계에서 하나씩 작업을 수행한다. 각 단계에서의 filtering, grouping, sorting, converting 이 가능하며, 이전 단계의 결과가 다음 단계의 입력으로 전달되므로 각 단계에서의 흐름을 명확하게 파악할 수 있다.</p> <h2 id="query와-pipeline-처리방식-차이">Query와 Pipeline 처리방식 차이</h2> <blockquote> <ul> <li>RDBMS Query: <strong>주로 단일 SQL 쿼리</strong>로 DB에서 <strong>결과</strong>를 즉시 반환.</li> <li>MongoDB Pipeline: 데이터를 <strong>여러 단계</strong>로 <strong>순차적으로</strong> 가공 가능하며, 최종 결과를 도출하는 <strong>처리 과정</strong>.</li> </ul> </blockquote> <ul> <li><em>물론 Query도 <code class="language-plaintext highlighter-rouge">with</code>문과 같은 CTE, 서브쿼리, 뷰 와 같은 데이터 처리 방식도 있어 복잡한 데이터 처리가 가능하다..!</em></li> </ul> <h3 id="예시">예시</h3> <h5 id="query">Query</h5> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">contract_number</span><span class="p">,</span>
    <span class="n">age</span><span class="p">,</span>
    <span class="n">gender</span><span class="p">,</span>
    <span class="n">JSON_ARRAYAGG</span><span class="p">(</span>
        <span class="n">JSON_OBJECT</span><span class="p">(</span>
            <span class="s1">'name'</span><span class="p">,</span> <span class="k">outer</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s1">'size'</span><span class="p">,</span> <span class="k">outer</span><span class="p">.</span><span class="k">size</span><span class="p">,</span>
            <span class="s1">'warehouse'</span><span class="p">,</span> <span class="k">outer</span><span class="p">.</span><span class="n">warehouse</span>
        <span class="p">)</span>
    <span class="p">)</span> <span class="k">AS</span> <span class="n">orders</span>
<span class="k">FROM</span> <span class="k">table</span>
<span class="k">WHERE</span> <span class="n">response</span><span class="p">.</span><span class="k">result</span> <span class="o">=</span> <span class="k">TRUE</span>
<span class="k">AND</span> <span class="k">outer</span><span class="p">.</span><span class="n">status</span> <span class="k">IN</span> <span class="p">(</span><span class="s1">'배송전'</span><span class="p">,</span> <span class="s1">'배송취하'</span><span class="p">)</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">contract_number</span><span class="p">;</span>
</code></pre></div></div> <h5 id="pipeline">Pipeline</h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">query</span> <span class="o">=</span> <span class="sh">'</span><span class="s">...</span><span class="sh">'</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="sh">"</span><span class="s">$match</span><span class="sh">"</span><span class="p">:</span> <span class="n">query</span>  <span class="c1"># 원하는 필터 조건 적용
</span>    <span class="p">},</span>
    <span class="p">{</span>
        <span class="sh">"</span><span class="s">$match</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span>  <span class="c1"># log.response.result가 True인 데이터만 필터
</span>            <span class="sh">"</span><span class="s">log.response.result</span><span class="sh">"</span><span class="p">:</span> <span class="bp">True</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="sh">"</span><span class="s">$unwind</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.orders</span><span class="sh">"</span>  <span class="c1"># orders 배열 펼침
</span>    <span class="p">},</span>
    <span class="p">{</span>
        <span class="sh">"</span><span class="s">$unwind</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.orders.outer</span><span class="sh">"</span>  <span class="c1"># outer 배열 펼침
</span>    <span class="p">},</span>
    <span class="p">{</span>
        <span class="sh">"</span><span class="s">$match</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span>
            <span class="sh">"</span><span class="s">log.response.orders.outer.status</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span> <span class="sh">"</span><span class="s">$in</span><span class="sh">"</span><span class="p">:</span> <span class="p">[</span><span class="sh">"</span><span class="s">배송전</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">배송취하</span><span class="sh">"</span><span class="p">]</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="sh">"</span><span class="s">$group</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span>
            <span class="sh">"</span><span class="s">_id</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.orders.contract_number</span><span class="sh">"</span><span class="p">,</span>  <span class="c1"># contract_number로 그룹화
</span>            <span class="sh">"</span><span class="s">original_id</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span> <span class="sh">"</span><span class="s">$first</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$_id</span><span class="sh">"</span> <span class="p">},</span>
            <span class="sh">"</span><span class="s">age</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span> <span class="sh">"</span><span class="s">$first</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.age</span><span class="sh">"</span> <span class="p">},</span>
            <span class="sh">"</span><span class="s">gender</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span> <span class="sh">"</span><span class="s">$first</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.gender</span><span class="sh">"</span> <span class="p">},</span>
            <span class="sh">"</span><span class="s">outer</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span>
                <span class="sh">"</span><span class="s">$push</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span>
                    <span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.orders.outer.name</span><span class="sh">"</span><span class="p">,</span>
                    <span class="sh">"</span><span class="s">domain_name</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.orders.outer.domain_name</span><span class="sh">"</span><span class="p">,</span>
                    <span class="sh">"</span><span class="s">size</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.orders.outer.size</span><span class="sh">"</span><span class="p">,</span>
                    <span class="sh">"</span><span class="s">warehouse</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.orders.outer.warehouse</span><span class="sh">"</span><span class="p">,</span>
                    <span class="sh">"</span><span class="s">discount_target</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.orders.outer.discount_target</span><span class="sh">"</span><span class="p">,</span>
                    <span class="sh">"</span><span class="s">status</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.orders.outer.status</span><span class="sh">"</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="sh">"</span><span class="s">$project</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span>
            <span class="sh">"</span><span class="s">_id</span><span class="sh">"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># id값 분리
</span>            <span class="sh">"</span><span class="s">original_id</span><span class="sh">"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># 원본 _id 반환
</span>            <span class="sh">"</span><span class="s">contract_number</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$_id</span><span class="sh">"</span><span class="p">,</span>
            <span class="sh">"</span><span class="s">age</span><span class="sh">"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="sh">"</span><span class="s">gender</span><span class="sh">"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="sh">"</span><span class="s">orders</span><span class="sh">"</span><span class="p">:</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">]</span>
</code></pre></div></div> <ul> <li>$match: 필터링</li> <li>$group: 그룹화</li> <li>$sort: 그룹화된 데이터 정렬</li> <li>$unwind: 원하는 배열 데이터 레벨에 접근</li> <li>$project: 반환할 컬럼 set</li> </ul>]]></content><author><name></name></author><category term="study"/><category term="database"/><summary type="html"><![CDATA[jupyter에서 DB를 연결해서 데이터를 다룰 때, RDB는 당연하게도 query라는 변수를 사용하고, MongoDB는 pipeline이라는 변수를 사용하는 것을 발견했다. 문득 왜 pipeline이라는 표현을 하는지 궁금해져서 정리하는 글이다.]]></summary></entry><entry><title type="html">꾸준히 하자, 블로그..!</title><link href="https://minngki.github.io/blog/2024/first/" rel="alternate" type="text/html" title="꾸준히 하자, 블로그..!"/><published>2024-12-29T17:20:00+09:00</published><updated>2024-12-29T17:20:00+09:00</updated><id>https://minngki.github.io/blog/2024/first</id><content type="html" xml:base="https://minngki.github.io/blog/2024/first/"><![CDATA[<h2 id="-블로그를-시작하게-된-계기">📝 블로그를 시작하게 된 계기</h2> <h3 id="️-벌써-2달-뒤면-4년차-개발자가-되어있을-나">⏱️ 벌써 2달 뒤면, 4년차 개발자가 되어있을 나..</h3> <p>velog에 깨작거리면서 썼던 게 1-2년차였던 것 같은데, 당시 프론트엔드 공부를 잠시 했을 때 작성한 것이기도 하고, 개발에 대한 열정이 크지도 않았을 때라 블로그는 썩어가고 있었다.<br/> 심지어 페이스북으로 가입한 계정이었는데, 아무 생각없이 페이스북을 탈퇴하며 로그인도 못 했다고 한다..</p> <p>3년차 개발자인데도, 그 흔한 개발 블로그도 없고 github contributions도 시들시들 그 자체라는 걸 보고, 이대로는 도태되겠다 라는 생각을 했다.</p> <p>취업시장에 제대로 발 담가보지 않았던 나는, 그저 보여주기 식이라며 블로그랑 깃헙이 그렇게 중요해? 하면서 오기 부리면서 내 자신을 합리화하기 바빴다. 내가 뇌 빼놓고 작성했기 때문에 시간낭비라고 생각했던 것 같다.</p> <p>더 늦기 전에, 최선을 다해 블로그를 작성해보자고 !</p> <h3 id="-대학원-준비가-날-살렸다">🙊 대학원 준비가 날 살렸다.</h3> <p>최근에 대학원 진학을 위해 면접을 본 적이 있다. 공부를 열심히 했지만 머릿 속에 인과관계와 흐름을 제대로 파악하고 있지 않았다. 그저 외우기만 했고, 제대로 외우지도 않은 지식을 안다고 생각하고 진도를 따라가기 바빴다. 면접을 본 직후, 바로 떨어질 거라는 것도 알았다. 떨어졌다는 낙담 보다는, 여태 이렇게 공부했다는 것에 충격을 먹고 공부 방식을 달리 해서 반드시 해내야겠다는 욕심이 더 생겼다.</p> <p><strong>내가 아는 걸 잘 설명해야 하고, 잘 이해하기 위해서는 지식을 내 것으로 만들어야 했다.</strong></p> <p>대학원 공부 뿐만 아니라 회사에서 프로젝트를 진행하면서 배운 점, 개발하면서 배운 지식이 많았지만 다 휘발되고 있었다. 성격 상 말을 잘 하는 성격도 아니라 제대로 모르면 입이 떨어지지 않는다는 걸 확연하게 느꼈다. 이직을 하든, 대학원을 가든, 결국엔 경쟁이고 나를 PR하기 위해선 “<strong>얼마나 잘 설명할 수 있는가</strong>“가 관건이었다.</p> <p>남들보다 더 머릿 속 체계를 잡기 어려워하는 것 같고 말로서 표현도 잘 못 하니, 남보다 더 열심히 해야하지 않을까 란 생각으로 이어졌다. 그치만 남들에 비해 해둔 것도 없고 오히려 부족해서 경각심을 가지고 시작하려고 한다.</p> <p>너무나도 당연하고 뻔한 말이지만 망각하고 있었던 나를 반성하며, 오래 걸리더라도 꾸준히 내가 겪은 것들을 내 것으로 만들어 기록하고자 한다.</p> <h3 id="️-github-pages-를-선택한-이유">🖥️ github pages 를 선택한 이유</h3> <p>장기적으로 쓸 생각을 하니, 질리지 않는 UI가 중요했고 하나의 도메인으로 날 설명하고 싶었다. 국내 플랫폼을 사용하게 되면, 왠지 모르게 장기적으로 사용하지 못 할 것 같은 느낌이 든다..</p> <p>플랫폼을 옮기는 일은 없었으면 해서, github pages를 선택했다. github pages는 자유도가 높아 나를 설명하기 좋은 적합한 플랫폼이라고 생각이 들었다. UI가 질리면 다른 테마만 적용하기만 하면 되니 크게 문제도 없고 말이다.</p> <h3 id="-앞으로의-계획">📍 앞으로의 계획</h3> <p>주로 회사에서 진행한 프로젝트 단위로 작성할 것이다. 회고를 작성하면서 미처 정리하지 못한 개발지식이나 일처리방식 같은 걸 따로 정리해서 부수적으로 포스팅할 생각이다.</p>]]></content><author><name></name></author><category term="writing"/><category term="retrospective"/><summary type="html"><![CDATA[📝 블로그를 시작하게 된 계기]]></summary></entry></feed>