<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://minngki.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://minngki.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-07-07T22:03:47+09:00</updated><id>https://minngki.github.io/feed.xml</id><title type="html">Minji Kim</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">MongoDB Aggregation Pipeline 내부 동작 원리와 최적화</title><link href="https://minngki.github.io/blog/2025/mongodb-aggregation/" rel="alternate" type="text/html" title="MongoDB Aggregation Pipeline 내부 동작 원리와 최적화"/><published>2025-01-14T22:20:00+09:00</published><updated>2025-01-14T22:20:00+09:00</updated><id>https://minngki.github.io/blog/2025/mongodb-aggregation</id><content type="html" xml:base="https://minngki.github.io/blog/2025/mongodb-aggregation/"><![CDATA[<p><a href="https://minngki.github.io/blog/2025/mongodb-pipeline/">MongoDB에서 ‘pipeline’이라는 표현을 사용하는 이유</a>가 궁금해 포스팅을 한 적이 있다. 그 과정에서 pipeline의 동작원리에 대해 더 깊은 궁금증이 생겨, 이번에는 MongoDB의 동작 원리를 파헤치고 정리한 글이다.</p> <h2 id="aggregation-pipeline의-내부-동작-개요">Aggregation Pipeline의 내부 동작 개요</h2> <p>이전에 작성한 글에서 MongoDB는 Aggregation Pipeline 실행 시 각 단계(<code class="language-plaintext highlighter-rouge">$match</code>, <code class="language-plaintext highlighter-rouge">$group</code>, <code class="language-plaintext highlighter-rouge">$sort</code>, <code class="language-plaintext highlighter-rouge">$lookup</code>)를 순차적으로 적용시킨다고 정리했었다. 여기서 더 세부적으로 정리하자면, Mongo 엔진은 다음과 같은 과정을 거친다.</p> <h4 id="1-parsing">1) Parsing</h4> <ul> <li>클라이언트가 전달한 pipeline array를 받아서, 각 단계에서 올바르고 유효한 문법인지 validate하는 과정이다.</li> <li>즉, 구문 분석과 타당성 검증을 담당한다.</li> </ul> <h4 id="2-planning">2) Planning</h4> <ul> <li>validation이 끝나면 실행 계획을 수립한다. 어떤 인덱스를 쓸지, 병렬 처리는 어떻게 할지, 단계의 순서는 어떻게 유지하거나 조정할지 등 실행 결로를 결정한다.</li> <li>실질적인 Optimization 작업이 이루어진다.</li> </ul> <h4 id="3-stage-execution">3) Stage Execution</h4> <ul> <li>실제 데이터(document)를 읽어서 각 단계의 <strong>연산(filtering, grouping, sorting)을 수행</strong>한다.</li> <li>각 단계는 독립적인 연산자처럼 동작하며, 앞 단계의 결과를 받아 연산 후 다음 단계로 넘어가는 방식이다.</li> </ul> <h4 id="4-returning">4) Returning</h4> <ul> <li>최종 단계까지 처리된 결과를 클라이언트에게 반환하거나, 특정 collection에 저장한다.</li> <li>해당 결과를 기존 collection에 덮어 쓸 수 있고, 새로운 collection 에 생성하거나 병합할 수 있다. <ul> <li>특정 collection에 기록하는 방법 <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">{</span>
      <span class="c1">// "aggregatedResults" collection이 없다면 새로 생성, or not 덮어쓰며 결과 저장.</span>
      <span class="dl">"</span><span class="s2">$out</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">aggregatedResults</span><span class="dl">"</span>
  <span class="p">}</span>
</code></pre></div> </div> </li> </ul> </li> </ul> <h2 id="optimization">Optimization</h2> <p>최적화 로직에 대해 조금만 자세히 살펴보자면,</p> <h4 id="1-인덱스-사용">1) 인덱스 사용</h4> <ul> <li><code class="language-plaintext highlighter-rouge">$sort</code> 앞 단계에서나 <code class="language-plaintext highlighter-rouge">$match</code>에 인덱스가 걸려 있으면, full collection 스캔을 최소화할 수 있게 index only scan을 진행하도록 실행 계획을 세운다. <ul> <li>Covered Query</li> </ul> </li> </ul> <h4 id="2-pipeline-stage-병합재배치">2) Pipeline stage 병합/재배치</h4> <ul> <li>내부적으로 <code class="language-plaintext highlighter-rouge">$match</code> 스테이지가 여러 번 등장하면, 가능한 한 앞단에서 합쳐서 수행하도록 최적화한다.</li> <li><code class="language-plaintext highlighter-rouge">$limit</code>,<code class="language-plaintext highlighter-rouge"> $skip</code> 등이 있다면, 이들을 앞단으로 당겨서 불필요한 연산을 줄일 수 있는지 검토한다.</li> <li><code class="language-plaintext highlighter-rouge">$sort</code>와 <code class="language-plaintext highlighter-rouge">$group</code>의 순서에 따라, 인덱스를 사용하는 방식이나 내부 동작이 달라지므로, 가끔 순서를 조정할 수도 있다.</li> </ul> <h2 id="mongo의-동작-원리-정리">mongo의 동작 원리 정리</h2> <h5 id="1-document-스캔-및-조회">1. Document 스캔 및 조회</h5> <ul> <li>파이프라인의 첫 단계에서 mongoDB는 collection에서 document를 읽기 시작한다.</li> <li><code class="language-plaintext highlighter-rouge">$match</code> 조건에 부합하는 문서만 통과시키기 때문에 앞 단에 <code class="language-plaintext highlighter-rouge">$match</code>로 filter를 걸어주는 게 효율적이다.</li> </ul> <h5 id="2-단계-별-연산-수행">2. 단계 별 연산 수행</h5> <h5 id="3-순차적으로-앞-단계의-결과를-다음-단계로-전달">3. 순차적으로 앞 단계의 결과를 다음 단계로 전달</h5> <h5 id="4-메모리디스크-사용">4. 메모리/디스크 사용</h5> <ul> <li><code class="language-plaintext highlighter-rouge">$sort</code>나 <code class="language-plaintext highlighter-rouge">$group</code>과 같은 많은 document를 한 번에 다루는 단계는 메모리에 중간 단계의 데이터를 보관한다.</li> <li>mongoDB는 기본 100MB까지 메모리를 사용하고, 이를 초과하면 <code class="language-plaintext highlighter-rouge">allowDiskUse</code> 옵션이 켜진 경우 디스크에 임시 공간을 활용한다고 한다. <ul> <li><em>회사에서 쌓인 log json은 크기가 커서 sort할 때, 과하게 오래 걸렸나 싶다..</em></li> </ul> </li> </ul> <h5 id="5-병렬-처리-sharded-cluster인-경우">5. 병렬 처리 (Sharded Cluster인 경우)</h5> <ul> <li>각 샤드에서 병렬로 부분 결과(ex.부분 집계)를 만들고, 해당 결과를 mongos(router) 혹은 최종 샤드에서 합치는 흐름을 거친다.</li> <li>수평 확장을 통해 대규모 데이터를 빠르게 처리할 때 사용한다.</li> <li><del>아직 사용해보지 않았지만 추후 다뤄보고 싶다..</del></li> </ul>]]></content><author><name></name></author><category term="study"/><category term="database"/><summary type="html"><![CDATA[MongoDB에서 ‘pipeline’이라는 표현을 사용하는 이유가 궁금해 포스팅을 한 적이 있다. 그 과정에서 pipeline의 동작원리에 대해 더 깊은 궁금증이 생겨, 이번에는 MongoDB의 동작 원리를 파헤치고 정리한 글이다.]]></summary></entry><entry><title type="html">MongoDB는 왜 ‘query’가 아니라 ‘pipeline’이라고 표현할까?</title><link href="https://minngki.github.io/blog/2025/mongodb-pipeline/" rel="alternate" type="text/html" title="MongoDB는 왜 ‘query’가 아니라 ‘pipeline’이라고 표현할까?"/><published>2025-01-13T04:20:00+09:00</published><updated>2025-01-13T04:20:00+09:00</updated><id>https://minngki.github.io/blog/2025/mongodb-pipeline</id><content type="html" xml:base="https://minngki.github.io/blog/2025/mongodb-pipeline/"><![CDATA[<p>jupyter에서 DB를 연결해서 데이터를 다룰 때, RDB는 당연하게도 query라는 변수를 사용하고, MongoDB는 pipeline이라는 변수를 사용하는 것을 발견했다. 문득 왜 pipeline이라는 표현을 하는지 궁금해져서 정리하는 글이다.</p> <h5 id="왜-mongo는-pipeline이라는-표현을-사용할까-">왜 Mongo는 pipeline이라는 표현을 사용할까 ?</h5> <p><code class="language-plaintext highlighter-rouge">Query</code>라는 표현 자체가 사용자가 원하는 특정 데이터가 무엇인지 명시(질의)하는 행위를 의미한다. 반면에, <code class="language-plaintext highlighter-rouge">Pipeline</code>은 데이터를 여러 단계에 거쳐 데이터를 처리하는 방식이다.</p> <p><code class="language-plaintext highlighter-rouge">Query</code>는 단순 질의를 강조하는 반면, <code class="language-plaintext highlighter-rouge">Pipeline</code>은 <strong>“처리 흐름”</strong>을 강조하는 용어로 보면 된다!</p> <p>겉으로는 당연한 것처럼 보일 수 있지만, 실제로 구조를 이해하면서 말로 풀어 보니 더 직관적으로 이해할 수 있었다.</p> <h2 id="파이프라인-개념">파이프라인 개념</h2> <p>파이프라인이란 데이터를 <strong>단계별로</strong> 처리하는 <strong>연속적인 작업</strong> 흐름을 말한다. Mongo의 aggregation pipeline 은 순차적으로 각 단계에서 하나씩 작업을 수행한다. 각 단계에서의 filtering, grouping, sorting, converting 이 가능하며, 이전 단계의 결과가 다음 단계의 입력으로 전달되므로 각 단계에서의 흐름을 명확하게 파악할 수 있다.</p> <h2 id="query와-pipeline-처리방식-차이">Query와 Pipeline 처리방식 차이</h2> <blockquote> <ul> <li>RDBMS Query: <strong>주로 단일 SQL 쿼리</strong>로 DB에서 <strong>결과</strong>를 즉시 반환.</li> <li>MongoDB Pipeline: 데이터를 <strong>여러 단계</strong>로 <strong>순차적으로</strong> 가공 가능하며, 최종 결과를 도출하는 <strong>처리 과정</strong>.</li> </ul> </blockquote> <ul> <li><em>물론 Query도 <code class="language-plaintext highlighter-rouge">with</code>문과 같은 CTE, 서브쿼리, 뷰 와 같은 데이터 처리 방식도 있어 복잡한 데이터 처리가 가능하다..!</em></li> </ul> <h3 id="예시">예시</h3> <h5 id="query">Query</h5> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">contract_number</span><span class="p">,</span>
    <span class="n">age</span><span class="p">,</span>
    <span class="n">gender</span><span class="p">,</span>
    <span class="n">JSON_ARRAYAGG</span><span class="p">(</span>
        <span class="n">JSON_OBJECT</span><span class="p">(</span>
            <span class="s1">'name'</span><span class="p">,</span> <span class="k">outer</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s1">'size'</span><span class="p">,</span> <span class="k">outer</span><span class="p">.</span><span class="k">size</span><span class="p">,</span>
            <span class="s1">'warehouse'</span><span class="p">,</span> <span class="k">outer</span><span class="p">.</span><span class="n">warehouse</span>
        <span class="p">)</span>
    <span class="p">)</span> <span class="k">AS</span> <span class="n">orders</span>
<span class="k">FROM</span> <span class="k">table</span>
<span class="k">WHERE</span> <span class="n">response</span><span class="p">.</span><span class="k">result</span> <span class="o">=</span> <span class="k">TRUE</span>
<span class="k">AND</span> <span class="k">outer</span><span class="p">.</span><span class="n">status</span> <span class="k">IN</span> <span class="p">(</span><span class="s1">'배송전'</span><span class="p">,</span> <span class="s1">'배송취하'</span><span class="p">)</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">contract_number</span><span class="p">;</span>
</code></pre></div></div> <h5 id="pipeline">Pipeline</h5> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">query</span> <span class="o">=</span> <span class="sh">'</span><span class="s">...</span><span class="sh">'</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="sh">"</span><span class="s">$match</span><span class="sh">"</span><span class="p">:</span> <span class="n">query</span>  <span class="c1"># 원하는 필터 조건 적용
</span>    <span class="p">},</span>
    <span class="p">{</span>
        <span class="sh">"</span><span class="s">$match</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span>  <span class="c1"># log.response.result가 True인 데이터만 필터
</span>            <span class="sh">"</span><span class="s">log.response.result</span><span class="sh">"</span><span class="p">:</span> <span class="bp">True</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="sh">"</span><span class="s">$unwind</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.orders</span><span class="sh">"</span>  <span class="c1"># orders 배열 펼침
</span>    <span class="p">},</span>
    <span class="p">{</span>
        <span class="sh">"</span><span class="s">$unwind</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.orders.outer</span><span class="sh">"</span>  <span class="c1"># outer 배열 펼침
</span>    <span class="p">},</span>
    <span class="p">{</span>
        <span class="sh">"</span><span class="s">$match</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span>
            <span class="sh">"</span><span class="s">log.response.orders.outer.status</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span> <span class="sh">"</span><span class="s">$in</span><span class="sh">"</span><span class="p">:</span> <span class="p">[</span><span class="sh">"</span><span class="s">배송전</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">배송취하</span><span class="sh">"</span><span class="p">]</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="sh">"</span><span class="s">$group</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span>
            <span class="sh">"</span><span class="s">_id</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.orders.contract_number</span><span class="sh">"</span><span class="p">,</span>  <span class="c1"># contract_number로 그룹화
</span>            <span class="sh">"</span><span class="s">original_id</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span> <span class="sh">"</span><span class="s">$first</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$_id</span><span class="sh">"</span> <span class="p">},</span>
            <span class="sh">"</span><span class="s">age</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span> <span class="sh">"</span><span class="s">$first</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.age</span><span class="sh">"</span> <span class="p">},</span>
            <span class="sh">"</span><span class="s">gender</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span> <span class="sh">"</span><span class="s">$first</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.gender</span><span class="sh">"</span> <span class="p">},</span>
            <span class="sh">"</span><span class="s">outer</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span>
                <span class="sh">"</span><span class="s">$push</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span>
                    <span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.orders.outer.name</span><span class="sh">"</span><span class="p">,</span>
                    <span class="sh">"</span><span class="s">domain_name</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.orders.outer.domain_name</span><span class="sh">"</span><span class="p">,</span>
                    <span class="sh">"</span><span class="s">size</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.orders.outer.size</span><span class="sh">"</span><span class="p">,</span>
                    <span class="sh">"</span><span class="s">warehouse</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.orders.outer.warehouse</span><span class="sh">"</span><span class="p">,</span>
                    <span class="sh">"</span><span class="s">discount_target</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.orders.outer.discount_target</span><span class="sh">"</span><span class="p">,</span>
                    <span class="sh">"</span><span class="s">status</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$log.response.orders.outer.status</span><span class="sh">"</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="sh">"</span><span class="s">$project</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span>
            <span class="sh">"</span><span class="s">_id</span><span class="sh">"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># id값 분리
</span>            <span class="sh">"</span><span class="s">original_id</span><span class="sh">"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># 원본 _id 반환
</span>            <span class="sh">"</span><span class="s">contract_number</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">$_id</span><span class="sh">"</span><span class="p">,</span>
            <span class="sh">"</span><span class="s">age</span><span class="sh">"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="sh">"</span><span class="s">gender</span><span class="sh">"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="sh">"</span><span class="s">orders</span><span class="sh">"</span><span class="p">:</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">]</span>
</code></pre></div></div> <ul> <li>$match: 필터링</li> <li>$group: 그룹화</li> <li>$sort: 그룹화된 데이터 정렬</li> <li>$unwind: 원하는 배열 데이터 레벨에 접근</li> <li>$project: 반환할 컬럼 set</li> </ul>]]></content><author><name></name></author><category term="study"/><category term="database"/><summary type="html"><![CDATA[jupyter에서 DB를 연결해서 데이터를 다룰 때, RDB는 당연하게도 query라는 변수를 사용하고, MongoDB는 pipeline이라는 변수를 사용하는 것을 발견했다. 문득 왜 pipeline이라는 표현을 하는지 궁금해져서 정리하는 글이다.]]></summary></entry></feed>